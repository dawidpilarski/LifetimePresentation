% !TeX Options = -shell-escape
\documentclass{panicsoftware-presentation}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}

\title{Lifetime of the C++ object}
\author{Dawid Pilarski}
\date{}

\institute{dawid.pilarski@tomtom.com \\ dawid.pilarski@panicsoftware.com \\ \href{http://blog.panicsoftware.com}{blog.panicsoftware.com} }

\newenvironment{itemizeSeq}{\begin{itemize}[<+-|alert@+>]}{\end{itemize}}
\newenvironment{itemizeNColorSeq}{\begin{itemize}[<+->]}{\end{itemize}}

\begin{document}

\begin{frame}
	\maketitle
\end{frame}

\begin{frame}{Agenda}
	\tableofcontents
\end{frame}

\begin{frame}{Who am I?}
			\centering \alert{Dawid Pilarski}
			\vskip 1em
	\begin{columns}[onlytextwidth]
		\begin{column}{0.7\textwidth}
			\begin{itemize}
				\item Senior Software Developer in TomTom
				\item Member of the ISO/JTC1/SC22/WG21
				\item Member of the PKN KT {\tiny(programming languages)}
				\item C++ blog writer
			\end{itemize}
		\end{column}
		\begin{column}{0.29\textwidth}
				\includegraphics[width=\linewidth]{Dawid_Pilarski.jpg}				
		\end{column}	
	\end{columns}
\end{frame}

\begin{frame}{Questions.}
	
	\vfill
	\centerline{Questions...}
	\vfill

\end{frame}

\begin{frame}{Question...}

\centerline{Do you think, that understanding objects and their lifetimes is \alert{basics}?}

\end{frame}

\begin{frame}{What we talk about are basics.}

	\centering
	\includegraphics[width=1.0\linewidth]{graphics/objects_basics.png}

\end{frame}


\section{Theory}

\begin{frame}{Title decomposition}

\centerline{What's the \only{lifetime}<1>\only{\alert{lifetime}}<2-> of your \only{object}<1-2>\only{\alert{object}}<3>?}
\pause
\begin{itemizeSeq}
	\item What is a lifetime?
	\item What is an object?
\end{itemizeSeq}

\end{frame}

\section*{Objects}

\begin{frame}{The object}

Objects are entities, that can be:
\begin{itemize}
	\item created
	\item destroyed
	\item refered to
	\item accessed
	\item manipulated
\end{itemize}

\end{frame}

\begin{frame}{The Object}

\begin{columns}
	\begin{column}{0.58\linewidth}
	
	Is created:
	\begin{itemizeSeq}
		\item by the definition
		\item by the new expression
		\item when changing active\\ member of a union
		\item by creation of the temporary
	\end{itemizeSeq}
	\end{column}

	\begin{column}{0.48\linewidth}
	
	\only{\centering\inputminted{\myCpp}{examples/object-definition.cpp}}<1>
	\only{\centering\inputminted{\myCpp}{examples/new-expression.cpp}}<2>
	\only{\centering\inputminted{\myCpp}{examples/union-active-member-change.cpp}}<3>
	\only{\centering\inputminted{\myCpp}{examples/temporary-creation.cpp}}<4>
	\end{column}

\end{columns}

\end{frame}


\newcounter{tmpCounter}
\begin{frame}{The object}

\begin{columns}
\begin{column}{0.3\linewidth}

Has:
\begin{itemizeSeq}
	\item optional name
	\item lifetime
	\item storage and it's duration
	\begin{itemizeSeq}
		\item static
		\item thread
		\item automatic
		\item dynamic
	\end{itemizeSeq}
	\item type
	\item value
\end{itemizeSeq}

\end{column}

\begin{column}{0.5\linewidth}
\only{\alert{program duration}}<4>
\only{\alert{thread duration}}<5>
\only{\alert{enclosing scope duration}}<6>
\only{\alert{controlled by user}}<7>
\end{column}

\end{columns}
\end{frame}

\begin{frame}{The reference}

\centerline{Is not an object {\scriptsize(although reference has lifetime)}}

\centerline{\footnotesize functions are not objects as well}

\end{frame}

\begin{frame}[fragile]{The variable}

\centerline{Is created by a \alert{declaration} of an \alert{object} or the \alert{reference}.}
\pause
\vfill

\begin{columns}[t]

\begin{column}{0.3\linewidth}
\begin{minted}{\myCpp}
int x;
\end{minted}
\vskip 1cm
Is a variable.

\end{column}
\pause

\begin{column}{0.3\linewidth}
\begin{minted}{\myCpp}
int& x = ...
\end{minted}
\vskip 1cm
Is variable.

\end{column}
\pause

\begin{column}{0.3\linewidth}
\begin{minted}{\myCpp}
struct X{int z;}x;
\end{minted}
\vskip 1cm
Neither \texttt{X} nor \texttt{z} are variables.\\
\texttt{x} is a variable.
\end{column}

\end{columns}

\end{frame}

\begin{frame}{Summary: variable, reference, object}
\centering
\begin{figure}
\resizebox{0.9\linewidth}{!}{
\begin{tikzpicture}
\begin{scope}[blend group=soft light]

\fill[blue!30!white] (-2.2,-0.25) circle[x radius=1cm, y radius=0.5cm];
\fill[blue!30!white] (2.2,-0.25) circle[x radius=1cm, y radius=0.5cm];
\fill[green!60!white] (-2.2,-1) circle[x radius=2cm, y radius=1.5cm];
\fill[orange!60!white] (2.2,-1) circle[x radius=2cm, y radius=1.5cm];

\end{scope}

\node at(-2.2,-0.25){Variables};
\node at(2.2,-0.25){Variables};
\node at(2.2,-1){References};
\node at(-2.2,-1){Objects};

\end{tikzpicture}}

\end{figure}

\end{frame}


\begin{frame}{Definitions}
	If you want to get precise definitions, you need to look at standard draft. In case of \href{http://cppreference.com}{\alert{cppreference}}:

	\begin{itemizeSeq}
		\item The object has been recently updated.
		\item The variable definition is unmaintained and unsupported.
		\item Same about references...
	\end{itemizeSeq}
\end{frame}

\section*{Lifetime}

\begin{frame}{What is a lifetime?}

\centerline{Lifetime is a \alert{runtime} property of an object.}

\vfill
\centering

\begin{tikzpicture}

\draw[fill=blue!30!white] (-.75, -2) rectangle (-0.1, 2);

\draw[dashed] (-1, 1) -- (2.5, 1);
\draw[dashed] (-1, -1) -- (2.5, -1);

\draw [decorate, decoration={brace, amplitude=5pt}] (0, 2) -- (0, 1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize object under construction};
\draw [decorate, decoration={brace, amplitude=5pt}] (0, 1) -- (0,-1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize lifetime};
\draw [decorate, decoration={brace, amplitude=5pt}] (0, -1) -- (0, -2) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize object under destruction};

\end{tikzpicture}
\vfill
\centerline{During the lifetime of an object you can use it without additional restrictions.}

\end{frame}

\begin{frame}{When does the lifetime start?}

\centerline{The lifetime of an object \alert{starts}, when:}

\begin{itemizeSeq}

\item storage with the proper alignment and size for type T is obtained
\item its initialization (if any)* is complete
\item if the object is a union member or subobject thereof, its lifetime only begins if that union member is the initialized member

\end{itemizeSeq}

\uncover<2>{\alert{*In case of default construction of trivial type, there is no initialization performed}}

\end{frame}

\begin{frame}{When does the lifetime end?}

\centerline{The lifetime of an object \alert{ends}:}

\begin{description}[<+-|alert@+>]

\item[class types] when it's destructor is called,
\item[non-class types] when we expect it to end its lifetime, 
\begin{itemize}
	\item when object exits the scope,
	\item delete expression,
	\item when temporary ends its lifetime etc.
\end{itemize}
\item[any type] when storage occupied by an object is reused or released.
\end{description}

\end{frame}

\section{Object model intuition}

\begin{frame}{The usual mindset towards object}

\begin{columns}

\begin{column}{0.3\linewidth}
\begin{itemizeSeq}
\item We have got a memory
\item Objects are the way to represent value in that memory
\end{itemizeSeq}
\end{column}
\begin{column}{0.56\linewidth}

\begin{tikzpicture}

\onslide<3-4>{
\fill[blue!20] (-2,0.5) rectangle (-1,1.5);
\draw[thick, blue!70, ->] (-3, 2) node[yshift=3mm]{\texttt{std::complex<int8\_t>}} to[out=0, in=180] (-2, 1);
}

\onslide<4>{
\fill[magenta!30] (-1,0.5) rectangle (0,1.5);
\draw[thick, magenta!70, ->] (1, 0) node[yshift=-3mm, xshift=-1.3cm]{\texttt{std::pair<int8\_t, int8\_t>}} to[out=180, in=0] (0, 1);
}

\draw[thick] (-2,0) rectangle node{...} (0,0.5);
\draw[thick] (-2,0.5) rectangle node{42} (0,1);
\draw[thick] (-2,1) rectangle node{24} (0,1.5);
\draw[thick] (-2,1.5) rectangle node{...} (0,2);

\end{tikzpicture}

\end{column}

\end{columns}


\end{frame}

\begin{frame}{Examples of invalid C++ - union type punning}

\inputminted{\myCpp}{examples/invalid_union_use.cpp}

\end{frame}

\begin{frame}{Examples of invalid C++ - reinterpret\_cast}

\inputminted{\myCpp}{examples/invalid-reinterpret-cast.cpp}

\end{frame}

\begin{frame}{reinterpret\_cast attempt 2}

\inputminted{\myCpp}{examples/invalid_reinterpret_cast-2.cpp}

\end{frame}

\section*{But... why?}

\begin{frame}{Why all the attempts are wrong?}

\centerline{Compiler \alert{doesn't} think in terms of \alert{objects and memory}}
\vskip 1cm
\pause 

\centerline{Compiler thinks in terms of \alert{objects and their types}.}

\end{frame}

\begin{frame}{Test - int + float}

\inputminted{\myCpp}{examples/TBAA-simple-example.cpp}

\vfill
\pause
\centerline{Q: \alert{What is the return value?}}

\end{frame}

\begin{frame}{Test - int + int}

\inputminted{\myCpp}{examples/Non-TBAA-simple-example.cpp}
\vfill
\pause
\centerline{Q: \alert{What is the return value?}}

\end{frame}

\begin{frame}{Assumptions, that compiler does}

\begin{columns}[t]

\begin{column}{0.58\linewidth}


\centerline{Code:}

\vfill

\inputminted[firstline=9]{\myCpp}{examples/TBAA-simple-example.cpp}

\end{column}


\begin{column}{0.28\linewidth}

\centerline{Assembly:}

\vfill

\centering\inputminted{gas}{examples/TBAA-simple-example.asm}

\end{column}

\end{columns}

\end{frame}

\begin{frame}{Assumptions, that compiler does}

\begin{columns}[t]

\begin{column}{0.58\linewidth}


\centerline{Code:}

\vfill

\inputminted[firstline=5]{\myCpp}{examples/Non-TBAA-simple-example.cpp}

\end{column}


\begin{column}{0.28\linewidth}

\centerline{Assembly:}

\vfill

\centering\inputminted{gas}{examples/Non-TBAA-simple-asembly.asm}

\end{column}

\end{columns}

\end{frame}

\begin{frame}{Conclusion}

We cannot allow 2 different objects (not subobjects) live:

\begin{itemize}
	\item in the same space.
	\item at the same time.
\end{itemize}

\end{frame}

\begin{frame}{Explanations: type punning in union}

\begin{columns}

\begin{column}{0.48\linewidth}
\inputminted{\myCpp}{examples/invalid_union_use.cpp}
\end{column}
\begin{column}{0.48\linewidth}

\centerline{\alert{errors:}}

\begin{itemizeSeq}
\item Accessing inactive member of union,
\item Reading not existing object.
\end{itemizeSeq}

\end{column}

\end{columns}


\end{frame}

\begin{frame}{How to do it right?}

\inputminted{\myCpp}{examples/invalid_union_use_right.cpp}

\pause

Additional benefit: \alert{No endianess issue here!}

\end{frame}

\begin{frame}{Explanations: reading from a stream}

\begin{columns}[t]

\begin{column}{0.48\linewidth}
\inputminted{\myCpp}{examples/invalid-reinterpret-cast.cpp}
\end{column}

\begin{column}{0.48\linewidth}
\centerline{\alert{errors:}}

\begin{itemizeSeq}
\item reading object of type T, that was not created
\end{itemizeSeq}
\end{column}

\end{columns}

\end{frame}

\begin{frame}{How to do it right?}

\inputminted{\myCpp}{examples/invalid-reinterpret-cast-right.cpp}

\end{frame}

\begin{frame}{Or with C++20}
\inputminted{\myCpp}{examples/invalid-reinterpret-cast-right-modern.cpp}
\end{frame}

\begin{frame}{Explanations: reading from a stream - placement new}

\begin{columns}

\begin{column}{0.48\linewidth}

\inputminted{\myCpp}{examples/invalid_reinterpret_cast-2.cpp}
\end{column}

\begin{column}{0.48\linewidth}

\begin{itemizeSeq}
\item placement new reuses the storage (ends lifetime of buff),
\item value is a runtime property of an object (doesn't exist outside of it's lifetime)
\item T is created uninitialized
\item reading T is reading indeterminate value, which is UB
\end{itemizeSeq}

\end{column}
\end{columns}
\end{frame}

\section*{std::launder}

\begin{frame}{Tricky placement new}

\begin{columns}

\begin{column}{0.48\linewidth}
\inputminted{\myCpp}{examples/placement-new-issue.cpp}
\end{column}

\begin{column}{0.48\linewidth}
\begin{itemizeSeq}
\item sometimes you know, there is an object of given type under given address.
\item but you cannot just \texttt{reinterpret\_cast} the pointer to get to the object.
\end{itemizeSeq}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{What's the solution to the problem?}

\begin{description}[<+-|alert@+>]
\item[Until C++14] No solution. Go on with UB.
\item[Since C++17] \texttt{std::launder}.
\end{description}

\end{frame}

\begin{frame}[fragile]{What is std::launder?}
\centerline{Reading \alert{cppreference}:}

\begin{minted}{\myCpp}
template <class T>
constexpr T* launder(T* p) noexcept;
\end{minted}

\pause

\only{Obtains a pointer to the object located at the address represented by p.}<2>
\only{Obtains a \alert{pointer to the object} located at the address represented by p.}<3> 
\end{frame}

\begin{frame}{Usage of std::launder}

\inputminted{\myCpp}{examples/placement-new-launder.cpp}

\end{frame}

\begin{frame}{Other use-cases of the std::launder}

\inputminted{\myCpp}{examples/non-assignable-launder.cpp}

Is this code valid? (drawings)

\end{frame}

\begin{frame}{Rules for placement new for such cases}

\centerline{\alert{You can do placement new on old object.}}
\pause
\centerline{\alert{Not always we can use original object (until C++20). For example:}}

\begin{itemizeSeq}
\item We cannot use original object when it has:
\begin{itemizeSeq}
\item references
\item const members
\end{itemizeSeq}
\end{itemizeSeq}

\end{frame}

\begin{frame}{Example: const member or reference}

\inputminted{\myCpp}{examples/non-assignable-launder-bad.cpp}

\end{frame}

\begin{frame}{Example: standard layout types}

\inputminted{\myCpp}{examples/non-assignable-launder-good.cpp}

\end{frame}

\section*{Implicit object creation}

\begin{frame}{Implicit object creation}
Until C++20 there is one case of implicit object creation:
\vskip 2em
\centerline{\alert{for defaulted, trivial assignment operators of union members.}}

\pause 

\vfill

What does that mean?

\end{frame}

\begin{frame}{Implicit object creation for unions}

\inputminted{\myCpp}{examples/implicit-obj-creation-unions.cpp}

\end{frame}

\begin{frame}{Implicit object creation for unions}

\inputminted{\myCpp}{examples/implicit-obj-creation-unions-nondefault.cpp}

\end{frame}

\begin{frame}{Implicit object creation for C++20}

\begin{columns}

\begin{column}{0.45\linewidth}


Implicit object creation in the C++20 will be extended for:

\begin{itemizeSeq}

\item malloc-like functions
\item operator new
\item std::allocator<T>::allocate
\item memcpy, memmove
\item creation of arrays of:
\begin{itemize}[<5->]
	\item char
	\item unsigned char
	\item std::byte
\end{itemize}

\end{itemizeSeq}

\end{column}

\begin{column}{0.55\linewidth}

\only{\inputminted{\myCpp}{examples/implicit-obj-creation-malloc.cpp}}<1>
\only{\inputminted{\myCpp}{examples/implicit-obj-creation-new.cpp}}<2>
\only{\inputminted{\myCpp}{examples/implicit-obj-creation-alloc.cpp}}<3>
\only{\inputminted{\myCpp}{examples/implicit-obj-creation-memcpy.cpp}}<4>
\only{\inputminted{\myCpp}{examples/implicit-obj-creation-array.cpp}}<5>

\end{column}

\end{columns}


\end{frame}

\section{Beyond the object lifetime.}

\begin{frame}{Lifetime}

\begin{columns}
\begin{column}{0.58\linewidth}
\begin{tikzpicture}

\draw[fill=blue!30!white] (-.75, -2) rectangle (-0.1, 2);

\draw[dashed] (-1, 1) -- (2.5, 1);
\draw[dashed] (-1, -1) -- (2.5, -1);

\only{\draw [decorate, decoration={brace, amplitude=5pt}] (0, 2) -- (0, 1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize \alert{object under construction}}}<1>;
\only{\draw [decorate, decoration={brace, amplitude=5pt}] (0, 2) -- (0, 1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize object under construction}}<2->;

\only{\draw [decorate, decoration={brace, amplitude=5pt}] (0, 1) -- (0,-1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize \alert{lifetime}}}<2>;
\only{\draw [decorate, decoration={brace, amplitude=5pt}] (0, 1) -- (0,-1) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize lifetime}}<3->;
\only{\draw [decorate, decoration={brace, amplitude=5pt}] (0, -1) -- (0, -2) node[xshift=1.35cm ,midway, text width=2cm]{\footnotesize \alert{object under destruction}}}<3>;

\end{tikzpicture}
\end{column}
\begin{column}{0.38\linewidth}

\only{Not for \alert{\texttt{trivially\_constructible}} types}<1>
\only{Not for \alert{\texttt{trivially\_destructible}} types. Optional for other types.}<3>

\end{column}
\end{columns}

\end{frame}

\begin{frame}{Concurrent access and vptr}

\inputminted{\myCpp}{examples/vptr-vcall.cpp}

\end{frame}

\begin{frame}{Concurrent access and vptr}

\inputminted{\myCpp}{examples/vptr-vcall-dtor.cpp}

\end{frame}

\begin{frame}{Avoid synchronisation in dtors}

\inputminted{\myCpp}{examples/dtors-sync.cpp}

\end{frame}

\begin{frame}{Summary}

\centerline{\alert{Do not call virtual functions beyond the lifetime of an object!}}

\end{frame}

\begin{frame}{dynamic\_cast and type\_id}

\texttt{\alert{Dynamic cast}} and \texttt{\alert{typeid}} cannot be used during construction or destruction if they don't refer to the base or current objects. 

\end{frame}

\begin{frame}{dynamic\_cast and type\_id examples}

\inputminted[fontsize=\footnotesize]{\myCpp}{examples/typeid.cpp}

\end{frame}

\begin{frame}{dynamic\_cast and type\_id examples}

\inputminted{\myCpp}{examples/typeid2.cpp}

\begin{block}{Output:}
4Base
0
0x7ffe5133e4c8
\end{block}

\end{frame}

\section*{Summary}

\begin{frame}{Summary}

\begin{itemizeSeq}
\item Do think about objects and its type not memory,
\item Don't do the type-punning in C++,
\item Be careful when using objects outside of their lifetimes. 
\end{itemizeSeq}

\end{frame}

\begin{frame}{Thank you!}

I would like to say thank you to:

\begin{itemize}
\item All the people on CppLang [standardese] in helping me to understand standard wording,
\item Richard Smith on making the implicit object creation proposal.
\end{itemize}

\end{frame}

\begin{frame}{Thank you!}

\centerline{Questions?}

\end{frame}

\begin{frame}{Thank you!}

\centerline{Thank you!}

\end{frame}


\end{document}